1) Square root of Integer

Using the concept of binary search, divide and conquer the numbers less than the given number. Since we need to find the floor of the square root, assign the latest lowest integer to be square root. 

Time Complexity - The set of integers are halved on every iteration; O(log n)


2) Rotated Array Search

The pivot is found out by comparing two consecutive numbers in the array, if the number at i+1 position in lesser than that in i position, i+1 is the pivot. This is found by divide and conquer by eliminating half of the array on every iteration. Once the pivot is found, if the number is less than pivot, it is not in the array. If it is more than pivot but less than last element of array, it is in the second half of the array. If the number is between first element of the array and the position before the pivot, we can eliminate the second half of the array after the pivot.

Time Complexity - The array is halved in every iteration of the search. O(log n)

3) Rearrange Array Digits

Merge sort is implemented to sort the array since it has good efficiency of O(nlog n). From the sorted array (descending order), each elements is alternatively picked and append to the string of digits which is output as integers.

Time Complexity - O(nlog n) Merge Sort + O(n) -> O(nlog n)

4) Dutch National Flag 

Using two pointers at the start and end of the array to swap 0 and 2 when found. When 2 is found and swapped, stall the iteration to check the element swapped by 2. 

Time Complexiity - O(n); One-Pass

5) Min, Max of Unsorted Array

Using two variables to keep track of min and max, the min and max values can be found in one single pass of the array. 

Time Complexity - O(n); One-Pass